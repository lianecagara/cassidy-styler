{"version":3,"sources":["../src/Datum.ts"],"sourcesContent":["import fs from \"fs/promises\";\r\n\r\n/**\r\n * Datum Namespace Utilities\r\n * -------------------------\r\n * Collection of functions and types for manipulating and querying structured data.\r\n * Includes JSON helpers, filtering, schema validation, and data encoding/decoding utilities.\r\n *\r\n * Author: Nealiana Kaye Cagara (@lianecagara)\r\n */\r\n\r\nexport namespace Datum {\r\n  /**\r\n   * Type-safe structure for `package.json`.\r\n   * Augments the base shape with optional fields and extensibility.\r\n   */\r\n  export type PackageJson = {\r\n    /** Optional name of the package */\r\n    name?: string;\r\n    /** Optional version of the package */\r\n    version?: string;\r\n    /** Runtime dependencies */\r\n    dependencies?: Record<string, string>;\r\n    /** Development dependencies */\r\n    devDependencies?: Record<string, string>;\r\n    /** Allows additional custom fields */\r\n    [key: string]: any;\r\n  };\r\n\r\n  /**\r\n   * Defines a flexible query interface for filtering values of type `T`.\r\n   * Mirrors MongoDB-style operators.\r\n   */\r\n  export type QueryOperator<T> =\r\n    | { $eq?: T } // Equal to\r\n    | { $ne?: T } // Not equal to\r\n    | { $gt?: T } // Greater than\r\n    | { $gte?: T } // Greater than or equal\r\n    | { $lt?: T } // Less than\r\n    | { $lte?: T } // Less than or equal\r\n    | { $in?: T[] } // Included in array\r\n    | { $nin?: T[] } // Not included in array\r\n    | { $regex?: RegExp }; // Matches RegExp\r\n\r\n  /**\r\n   * Filters object type `T` based on per-key conditions.\r\n   * Each key may be matched directly or via an operator.\r\n   */\r\n  export type Query<T> = Partial<\r\n    Record<keyof T, QueryOperator<T[keyof T]> | T[keyof T]>\r\n  >;\r\n\r\n  /**\r\n   * Schema type for object validation.\r\n   * Can be:\r\n   * - a primitive type string (e.g., 'string', 'number')\r\n   * - a class constructor (e.g., Date)\r\n   * - a recursive object structure\r\n   */\r\n  export type Schema = string | Function | { [key: string]: Schema };\r\n\r\n  /**\r\n   * Reads and parses a package.json file asynchronously.\r\n   * @param pkgPath - Path to the package.json file (default: \"./package.json\")\r\n   * @returns Promise resolving to the parsed PackageJson object, or null if read/parse fails\r\n   */\r\n  export async function readPackageJson(\r\n    pkgPath = \"./package.json\"\r\n  ): Promise<PackageJson | null> {\r\n    try {\r\n      const data = await fs.readFile(pkgPath, \"utf-8\");\r\n      return JSON.parse(data);\r\n    } catch {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Retrieves the `name` field from a package.json file asynchronously.\r\n   * @param pkgPath - Path to the package.json file (default: \"./package.json\")\r\n   * @returns Promise resolving to the package name string or null if not found/error\r\n   */\r\n  export async function getPackageName(\r\n    pkgPath = \"./package.json\"\r\n  ): Promise<string | null> {\r\n    const pkg = await readPackageJson(pkgPath);\r\n    return pkg?.name ?? null;\r\n  }\r\n\r\n  /**\r\n   * Retrieves the `version` field from a package.json file asynchronously.\r\n   * @param pkgPath - Path to the package.json file (default: \"./package.json\")\r\n   * @returns Promise resolving to the package version string or null if not found/error\r\n   */\r\n  export async function getPackageVersion(\r\n    pkgPath = \"./package.json\"\r\n  ): Promise<string | null> {\r\n    const pkg = await readPackageJson(pkgPath);\r\n    return pkg?.version ?? null;\r\n  }\r\n\r\n  /**\r\n   * Updates the package.json file at the specified path by applying an updater function.\r\n   * Reads the existing package.json, applies the updater, and writes back the result.\r\n   * @param pkgPath - Path to the package.json file\r\n   * @param updater - Function receiving the current PackageJson and returning the updated PackageJson\r\n   * @returns Promise resolving when the update and write operation completes\r\n   */\r\n  export async function updatePackageJson(\r\n    pkgPath: string,\r\n    updater: (pkg: PackageJson) => PackageJson\r\n  ): Promise<void> {\r\n    const pkg = (await readPackageJson(pkgPath)) || ({} as PackageJson);\r\n    const updated = updater(pkg);\r\n    await fs.writeFile(pkgPath, JSON.stringify(updated, null, 2));\r\n  }\r\n\r\n  /**\r\n   * Parses a JSON string into an object of type T.\r\n   * Returns null if parsing fails.\r\n   * @param jsonStr - JSON string to parse\r\n   * @returns Parsed object of type T or null if invalid JSON\r\n   */\r\n  export function parseJson<T>(jsonStr: string): T | null {\r\n    try {\r\n      return JSON.parse(jsonStr);\r\n    } catch {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Stringifies an object into a JSON string.\r\n   * Optionally pretty-prints with 2-space indentation.\r\n   * @param obj - Object to stringify\r\n   * @param pretty - If true, format JSON with indentation (default: false)\r\n   * @returns JSON string representation of the object\r\n   */\r\n  export function stringifyJson(obj: unknown, pretty = false): string {\r\n    return pretty ? JSON.stringify(obj, null, 2) : JSON.stringify(obj);\r\n  }\r\n\r\n  /**\r\n   * Validates if an object matches a given schema.\r\n   * Supports primitive type strings, constructor functions, and nested schemas.\r\n   * @param obj - Object to validate\r\n   * @param schema - Schema definition to validate against\r\n   * @returns True if object matches schema, false otherwise\r\n   */\r\n  export function validateSchema(obj: unknown, schema: Schema): boolean {\r\n    if (typeof schema === \"string\") {\r\n      return typeof obj === schema;\r\n    }\r\n\r\n    if (typeof schema === \"function\") {\r\n      return obj instanceof schema;\r\n    }\r\n\r\n    if (\r\n      typeof schema === \"object\" &&\r\n      schema !== null &&\r\n      typeof obj === \"object\" &&\r\n      obj !== null\r\n    ) {\r\n      for (const key in schema) {\r\n        if (!validateSchema((obj as any)[key], schema[key])) {\r\n          return false;\r\n        }\r\n      }\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Internal helper to check if a value matches a query condition or operator.\r\n   * Supports equality, inequality, comparison, inclusion, and regex operators.\r\n   * @param value - The value to test\r\n   * @param condition - Query condition or direct value\r\n   * @returns True if value matches condition, false otherwise\r\n   */\r\n  function matchesField<T>(value: T, condition: QueryOperator<T> | T): boolean {\r\n    if (condition instanceof RegExp) {\r\n      return typeof value === \"string\" && condition.test(value);\r\n    }\r\n\r\n    if (typeof condition !== \"object\" || condition === null) {\r\n      return value === condition;\r\n    }\r\n\r\n    if (\r\n      typeof value === \"object\" &&\r\n      value !== null &&\r\n      !Array.isArray(value) &&\r\n      !(\r\n        \"$eq\" in condition ||\r\n        \"$ne\" in condition ||\r\n        \"$gt\" in condition ||\r\n        \"$gte\" in condition ||\r\n        \"$lt\" in condition ||\r\n        \"$lte\" in condition ||\r\n        \"$in\" in condition ||\r\n        \"$nin\" in condition ||\r\n        \"$regex\" in condition\r\n      )\r\n    ) {\r\n      for (const key in condition) {\r\n        if (!matchesField((value as any)[key], (condition as any)[key])) {\r\n          return false;\r\n        }\r\n      }\r\n      return true;\r\n    }\r\n\r\n    for (const op in condition) {\r\n      const condVal = (condition as any)[op];\r\n      switch (op) {\r\n        case \"$eq\":\r\n          if (value !== condVal) return false;\r\n          break;\r\n        case \"$ne\":\r\n          if (value === condVal) return false;\r\n          break;\r\n        case \"$gt\":\r\n          if (!(value > condVal)) return false;\r\n          break;\r\n        case \"$gte\":\r\n          if (!(value >= condVal)) return false;\r\n          break;\r\n        case \"$lt\":\r\n          if (!(value < condVal)) return false;\r\n          break;\r\n        case \"$lte\":\r\n          if (!(value <= condVal)) return false;\r\n          break;\r\n        case \"$in\":\r\n          if (!Array.isArray(condVal) || !condVal.includes(value)) return false;\r\n          break;\r\n        case \"$nin\":\r\n          if (Array.isArray(condVal) && condVal.includes(value)) return false;\r\n          break;\r\n        case \"$regex\":\r\n          if (typeof value !== \"string\" || !condVal.test(value)) return false;\r\n          break;\r\n        default:\r\n          return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Filters data entries based on a query object.\r\n   * Supports data as a Record or Map.\r\n   * @param data - Data collection to query (Record or Map)\r\n   * @param query - Query object specifying filter conditions\r\n   * @returns Array of matching data items\r\n   */\r\n  export function queryData<T>(\r\n    data: Record<string, T> | Map<string, T>,\r\n    query: Query<T>\r\n  ): T[] {\r\n    const items =\r\n      data instanceof Map ? Array.from(data.values()) : Object.values(data);\r\n    return items.filter((item) => {\r\n      for (const key in query) {\r\n        const condition = query[key];\r\n        const val = (item as any)[key];\r\n        if (!matchesField(val, condition as any)) {\r\n          return false;\r\n        }\r\n      }\r\n      return true;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Returns the key or keys in the object that match the given value.\r\n   * @param value - The value to search for.\r\n   * @param parentObj - The object to search within.\r\n   * @returns The first matching key as a string, or an array of matching keys, or null if none found.\r\n   */\r\n  export function keyOf<T extends object>(\r\n    value: unknown,\r\n    parentObj: T\r\n  ): string | string[] | null {\r\n    const keys = Object.entries(parentObj)\r\n      .filter(([_, v]) => v === value)\r\n      .map(([k]) => k);\r\n\r\n    if (keys.length === 0) return null;\r\n    return keys.length === 1 ? keys[0] : keys;\r\n  }\r\n\r\n  /**\r\n   * Returns the value or values from the object for the given key(s).\r\n   * @param key - A single key or an array of keys.\r\n   * @param parentObj - The object to retrieve values from.\r\n   * @returns The value for a single key, an array of values for multiple keys, or null if not found.\r\n   */\r\n  export function valueOf<T extends object>(\r\n    key: keyof T | (keyof T)[],\r\n    parentObj: T\r\n  ): T[keyof T] | T[keyof T][] | null {\r\n    if (Array.isArray(key)) {\r\n      const values = key\r\n        .map((k) => parentObj[k])\r\n        .filter((v) => v !== undefined);\r\n\r\n      if (values.length === 0) return null;\r\n      return values;\r\n    }\r\n\r\n    const val = parentObj[key];\r\n    return val !== undefined ? val : null;\r\n  }\r\n\r\n  /**\r\n   * Returns a new array containing only unique elements from the input array.\r\n   *\r\n   * - If no callback is provided, uniqueness is determined using strict equality (`===`).\r\n   * - If a callback is provided, it is used to derive a value from each item for uniqueness comparison.\r\n   *\r\n   * @template T - Type of items in the input array\r\n   * @template K - Type of key returned by the callback function (if provided)\r\n   *\r\n   * @param array - The input array to filter.\r\n   * @param callback - Optional function to generate a comparison key for each item.\r\n   *\r\n   * @returns A new array containing only unique items.\r\n   *\r\n   * @example\r\n   * toUniqueArray([1, 2, 2, 3]); // [1, 2, 3]\r\n   *\r\n   * @example\r\n   * toUniqueArray(['one', 'two', 'three'], str => str.length); // ['one', 'three']\r\n   *\r\n   * @example\r\n   * toUniqueArray([{ id: 1 }, { id: 2 }, { id: 1 }], obj => obj.id); // [{ id: 1 }, { id: 2 }]\r\n   */\r\n  export function toUniqueArray<T, K = T>(\r\n    array: T[],\r\n    callback?: (item: T) => K\r\n  ): T[] {\r\n    const seen = new Set<K | T>();\r\n    const result: T[] = [];\r\n\r\n    for (const item of array) {\r\n      const key = callback ? callback(item) : item;\r\n      if (!seen.has(key)) {\r\n        seen.add(key);\r\n        result.push(item);\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /** Permissible object keys in TypeScript */\r\n  export type ObjectKey = string | number | symbol;\r\n\r\n  /**\r\n   * Decodes a game ID string from a custom web-safe base64 format.\r\n   *\r\n   * - Removes the GAME_ID_PREFIX if present.\r\n   * - Adds padding to make the base64 valid.\r\n   * - Decodes from base64 and removes the `custom_` prefix (if any).\r\n   *\r\n   * @param input - Encoded game ID string (e.g., from URL or database).\r\n   * @returns Decoded UTF-8 string, or original input if decoding fails.\r\n   */\r\n  export function decodeGameID(input: string) {\r\n    input = `${input}`;\r\n\r\n    input = input.replace(GAME_ID_PREFIX, \"\");\r\n    const pad = input.length % 4;\r\n    if (pad > 0) {\r\n      input += \"=\".repeat(4 - pad);\r\n    }\r\n    try {\r\n      return Buffer.from(input, \"base64\")\r\n        .toString(\"utf8\")\r\n        .replaceAll(\"custom_\", \"\");\r\n    } catch (e) {\r\n      return input;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Prefix used to mark encoded game IDs in web-safe format.\r\n   * Used by `encodeGameID` and `decodeGameID`.\r\n   */\r\n  export const GAME_ID_PREFIX = \"web:\";\r\n\r\n  /**\r\n   * Encodes a UTF-8 string into a custom base64 game ID format.\r\n   *\r\n   * - Encodes the input string using standard base64.\r\n   * - Adds the GAME_ID_PREFIX.\r\n   *\r\n   * @param input - Raw string to encode as a game ID.\r\n   * @returns Encoded game ID string or the original input if encoding fails.\r\n   */\r\n  export function encodeGameID(input: string) {\r\n    input = `${input}`;\r\n    try {\r\n      if (input.startsWith(GAME_ID_PREFIX)) {\r\n        return input;\r\n      }\r\n      const encodedIP = Buffer.from(input.replaceAll(\"custom_\", \"\"))\r\n        .toString(\"base64\")\r\n        .replace(/=/g, \"\");\r\n      return `${GAME_ID_PREFIX}${encodedIP}`;\r\n    } catch (error) {\r\n      return input;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Encodes a UTF-8 string into a custom base64 game ID format.\r\n   *\r\n   * - Encodes the input string using standard base64.\r\n   * - Replaces `+`, `/`, and `=` characters to make it URL-safe.\r\n   * - Adds the GAME_ID_PREFIX.\r\n   *\r\n   * @param input - Raw string to encode as a game ID.\r\n   * @returns Encoded game ID string or the original input if encoding fails.\r\n   */\r\n  export function encodeGameIDLegacy(input: string) {\r\n    try {\r\n      const encodedIP = Buffer.from(input)\r\n        .toString(\"base64\")\r\n        .replace(/[+/=]/g, (match) => ({ \"+\": \"0\", \"/\": \"1\", \"=\": \"\" }[match] ?? \"\"));\r\n      return `${GAME_ID_PREFIX}${encodedIP}`;\r\n    } catch (error) {\r\n      return input;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates a proxy-based object that behaves like a plain object,\r\n   * but is backed by an internal `Map`. Allows for:\r\n   *\r\n   * - Map-style access and mutation.\r\n   * - Proxy-based integration with object semantics (`in`, `for...in`, etc.).\r\n   *\r\n   * @template T - Type of the original object.\r\n   * @param plainObj - An optional base object to initialize the map from.\r\n   * @returns An object containing:\r\n   *   - `map`: the internal `Map` storing key-value pairs.\r\n   *   - `proxied`: a proxy object with object-like behavior powered by the `Map`.\r\n   *\r\n   * @example\r\n   * const { map, proxied } = makeMapPlain({ a: 1 });\r\n   * proxied.b = 2;\r\n   * console.log(map.get(\"b\")); // 2\r\n   */\r\n  export function makeMapPlain<T extends Record<ObjectKey, any>>(\r\n    plainObj: T = {} as T\r\n  ) {\r\n    const internalMap = new Map<keyof T, T[keyof T]>(\r\n      Object.entries(plainObj) as [keyof T, T[keyof T]][]\r\n    );\r\n\r\n    const target: T = Object.create(Object.getPrototypeOf(plainObj));\r\n\r\n    const handler: ProxyHandler<T> = {\r\n      get(target, prop, receiver) {\r\n        if (prop === Symbol.iterator) {\r\n          return function* () {\r\n            for (const [key, value] of internalMap) {\r\n              yield [key, value];\r\n            }\r\n          };\r\n        }\r\n        if (typeof prop === \"symbol\" || prop in Object.prototype) {\r\n          return Reflect.get(target, prop, receiver);\r\n        }\r\n        return internalMap.get(prop as keyof T);\r\n      },\r\n      set(_target, prop, value, _receiver) {\r\n        internalMap.set(prop as keyof T, value);\r\n        return true;\r\n      },\r\n      deleteProperty(_target, prop) {\r\n        return internalMap.delete(prop as keyof T);\r\n      },\r\n      has(_target, prop) {\r\n        return internalMap.has(prop as keyof T);\r\n      },\r\n      ownKeys(_target) {\r\n        return Array.from(internalMap.keys()) as Array<string | symbol>;\r\n      },\r\n      getOwnPropertyDescriptor(_target, prop) {\r\n        if (internalMap.has(prop as keyof T)) {\r\n          return {\r\n            value: internalMap.get(prop as keyof T),\r\n            writable: true,\r\n            enumerable: true,\r\n            configurable: true,\r\n          };\r\n        }\r\n        return undefined;\r\n      },\r\n      defineProperty(_target, prop, descriptor) {\r\n        if (\"value\" in descriptor && descriptor.value !== undefined) {\r\n          internalMap.set(prop as keyof T, descriptor.value);\r\n        } else if (!descriptor.get && !descriptor.set) {\r\n          internalMap.delete(prop as keyof T);\r\n        }\r\n        return true;\r\n      },\r\n      getPrototypeOf(target) {\r\n        return Object.getPrototypeOf(target);\r\n      },\r\n      setPrototypeOf(target, proto) {\r\n        Object.setPrototypeOf(target, proto);\r\n        return true;\r\n      },\r\n      isExtensible(_target) {\r\n        return true;\r\n      },\r\n      preventExtensions(_target) {\r\n        return false;\r\n      },\r\n    };\r\n\r\n    const proxied = new Proxy(target, handler);\r\n    return { map: internalMap, proxied };\r\n  }\r\n\r\n  /**\r\n   * Returns a shuffled version of the input array or object.\r\n   *\r\n   * - Arrays are shuffled using the Fisher-Yates algorithm.\r\n   * - Objects are converted to key-value entries, shuffled, then reconstructed.\r\n   *\r\n   * @template T - Type of array elements or object values.\r\n   * @param inp - Input array or object to shuffle.\r\n   * @returns Shuffled array or object of the same type.\r\n   *\r\n   * @example\r\n   * shuffle([1, 2, 3]); // e.g., [3, 1, 2]\r\n   * shuffle({ a: 1, b: 2 }); // e.g., { b: 2, a: 1 }\r\n   */\r\n  export function shuffle<T>(array: T[]): T[];\r\n\r\n  export function shuffle<O extends Record<ObjectKey, any>>(object: O): O;\r\n\r\n  export function shuffle(inp: any[] | Record<ObjectKey, any>) {\r\n    if (!Array.isArray(inp)) {\r\n      return Object.fromEntries(shuffle(Object.entries(inp)));\r\n    } else {\r\n      return fisherYates(inp);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns a random integer between the given min and max values (inclusive).\r\n   *\r\n   * - Both `min` and `max` are inclusive.\r\n   * - If `min` is greater than `max`, the values are swapped internally.\r\n   *\r\n   * @param min - The lower bound (inclusive).\r\n   * @param max - The upper bound (inclusive).\r\n   * @returns A random integer within the specified range.\r\n   *\r\n   * @example\r\n   * randomInt(1, 5); // e.g., 3\r\n   * randomInt(5, 5); // 5\r\n   * randomInt(10, 1); // e.g., 7 (handles swapped bounds)\r\n   */\r\n  export function randomInt(min: number, max: number): number {\r\n    if (min > max) [min, max] = [max, min];\r\n    return Math.floor(Math.random() * (max - min + 1)) + min;\r\n  }\r\n\r\n  /**\r\n   * Shuffles an array in-place using the Fisher-Yates algorithm.\r\n   *\r\n   * - Produces a uniformly random permutation.\r\n   * - Returns a new array (does not mutate the original).\r\n   *\r\n   * @template T - Type of elements in the array.\r\n   * @param array - Input array to shuffle.\r\n   * @returns A new array with shuffled elements.\r\n   *\r\n   * @example\r\n   * fisherYates([1, 2, 3]); // e.g., [2, 3, 1]\r\n   */\r\n  export function fisherYates<T>(array: T[]): T[] {\r\n    const a = [...array];\r\n    for (let i = a.length - 1; i > 0; i--) {\r\n      const j = Math.floor(Math.random() * (i + 1));\r\n      [a[i], a[j]] = [a[j], a[i]];\r\n    }\r\n    return a;\r\n  }\r\n\r\n  /**\r\n   * Recursively sorts the keys of an object to produce a normalized structure.\r\n   * Useful for consistent hashing, equality checks, or serialization where key order matters.\r\n   *\r\n   * @template T\r\n   * @param input - The input to normalize, which may be an object, array, or primitive.\r\n   * @returns A new object/array with keys sorted recursively, or the original primitive value.\r\n   *\r\n   * @example\r\n   * const obj = { b: 1, a: { d: 4, c: 3 } };\r\n   * const normalized = normalize(obj);\r\n   * // normalized = { a: { c: 3, d: 4 }, b: 1 }\r\n   */\r\n  export function normalize<T>(input: T): T {\r\n    if (Array.isArray(input)) {\r\n      return input.map(normalize) as T;\r\n    } else if (input !== null && typeof input === \"object\") {\r\n      const sorted = Object.keys(input)\r\n        .sort()\r\n        .reduce((acc, key) => {\r\n          acc[key] = normalize((input as any)[key]);\r\n          return acc;\r\n        }, {} as any);\r\n      return sorted as T;\r\n    }\r\n    return input;\r\n  }\r\n\r\n  /**\r\n   * Validates that an object conforms to a partial schema of validation functions.\r\n   * Each schema key maps to a function that returns true if the value is valid, false otherwise.\r\n   * Does not throw; instead returns a tuple of validity and error messages.\r\n   *\r\n   * @template T extends object\r\n   * @param obj - The object to validate.\r\n   * @param schema - Partial validation schema.\r\n   * @returns A tuple where the first element indicates overall validity,\r\n   *   and the second is an array of error messages for failed validations.\r\n   *\r\n   * @example\r\n   * const schema = {\r\n   *   age: (val) => typeof val === \"number\" && val > 0,\r\n   *   name: (val) => typeof val === \"string\" && val.length > 0,\r\n   * };\r\n   * const [isValid, errors] = conform({ age: 25, name: \"Alice\" }, schema);\r\n   */\r\n  export function conform<T extends object>(\r\n    obj: any,\r\n    schema: Partial<Record<keyof T, (val: any) => boolean>>\r\n  ): [boolean, string[]] {\r\n    const errors: string[] = [];\r\n    for (const key in schema) {\r\n      if (!schema[key]!(obj[key])) {\r\n        errors.push(`Key '${key}' failed validation.`);\r\n      }\r\n    }\r\n    return [errors.length === 0, errors];\r\n  }\r\n\r\n  /**\r\n   * Creates a new object by picking only the specified keys from the input object.\r\n   *\r\n   * @template T extends object, K extends keyof T\r\n   * @param obj - Source object to pick properties from.\r\n   * @param keys - Array of keys to select.\r\n   * @returns New object containing only the picked keys.\r\n   *\r\n   * @example\r\n   * const obj = { a: 1, b: 2, c: 3 };\r\n   * const picked = pick(obj, ['a', 'c']);\r\n   * // picked = { a: 1, c: 3 }\r\n   */\r\n  export function pick<T extends object, K extends keyof T>(\r\n    obj: T,\r\n    keys: K[]\r\n  ): Pick<T, K> {\r\n    const result = {} as Pick<T, K>;\r\n    for (const key of keys) {\r\n      if (key in obj) result[key] = obj[key];\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Infers the simple type or shape of a given value as a string.\r\n   * Recognizes \"array\", \"null\", or the result of `typeof`.\r\n   *\r\n   * @param value - The value to infer the type of.\r\n   * @returns The inferred type string: \"array\", \"null\", or `typeof` result.\r\n   *\r\n   * @example\r\n   * infer([1,2]); // \"array\"\r\n   * infer(null);  // \"null\"\r\n   * infer(123);   // \"number\"\r\n   */\r\n  export function infer(value: any[]): \"array\";\r\n  export function infer(value: null): \"null\";\r\n  export function infer(value: string): \"string\";\r\n  export function infer(value: number): \"number\";\r\n  export function infer(value: boolean): \"boolean\";\r\n  export function infer(value: undefined): \"undefined\";\r\n  export function infer(value: Function): \"function\";\r\n  export function infer(value: object): \"object\";\r\n  export function infer(value: any): string;\r\n\r\n  export function infer(value: any): string {\r\n    if (Array.isArray(value)) return \"array\";\r\n    if (value === null) return \"null\";\r\n    return typeof value;\r\n  }\r\n\r\n  /**\r\n   * Recursively searches an object to find the path (array of keys) to a given target value.\r\n   * Returns null if the target is not found.\r\n   *\r\n   * @param obj - The object to search within.\r\n   * @param target - The target value to find.\r\n   * @param path - Accumulated path during recursion (for internal use).\r\n   * @returns Array of keys representing the path to the target, or null if not found.\r\n   *\r\n   * @example\r\n   * const obj = { a: { b: { c: 42 } } };\r\n   * trace(obj, 42); // [\"a\", \"b\", \"c\"]\r\n   */\r\n  export function trace(\r\n    obj: any,\r\n    target: any,\r\n    path: string[] = []\r\n  ): string[] | null {\r\n    if (obj === target) return path;\r\n    if (typeof obj !== \"object\" || obj === null) return null;\r\n\r\n    for (const key in obj) {\r\n      const result = trace(obj[key], target, [...path, key]);\r\n      if (result) return result;\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Converts an array of objects into a lookup map keyed by a specified object property.\r\n   *\r\n   * @template T, K extends keyof T\r\n   * @param array - Array of objects to index.\r\n   * @param key - Key property name to use as the map key.\r\n   * @returns Object mapping from stringified key values to corresponding objects.\r\n   *\r\n   * @example\r\n   * const users = [{ id: 1, name: \"Alice\" }, { id: 2, name: \"Bob\" }];\r\n   * const userMap = index(users, \"id\");\r\n   * // userMap = { \"1\": { id: 1, name: \"Alice\" }, \"2\": { id: 2, name: \"Bob\" } }\r\n   */\r\n  export function index<T, K extends keyof T>(\r\n    array: T[],\r\n    key: K\r\n  ): Record<string, T> {\r\n    return array.reduce((acc, item) => {\r\n      const id = String(item[key]);\r\n      acc[id] = item;\r\n      return acc;\r\n    }, {} as Record<string, T>);\r\n  }\r\n\r\n  /**\r\n   * Remaps keys of an object according to a mapping function or key map object.\r\n   * If no mapping exists for a key, it retains the original key.\r\n   *\r\n   * @template T extends object\r\n   * @param obj - The source object whose keys will be remapped.\r\n   * @param mapper\r\n   *   Either an object mapping old keys to new keys, or a function that returns the new key for each entry.\r\n   * @returns New object with remapped keys and original values.\r\n   *\r\n   * @example\r\n   * remap({ a: 1, b: 2 }, { a: \"alpha\" }); // { alpha: 1, b: 2 }\r\n   * remap({ a: 1, b: 2 }, (k, v) => k.toUpperCase()); // { A: 1, B: 2 }\r\n   */\r\n  export function remap<T extends object>(\r\n    obj: T,\r\n    mapper:\r\n      | { [K in keyof T]?: string }\r\n      | ((key: keyof T, value: T[keyof T]) => string)\r\n  ): Record<string, any> {\r\n    const result: Record<string, any> = {};\r\n    for (const key in obj) {\r\n      const newKey =\r\n        typeof mapper === \"function\"\r\n          ? mapper(key, obj[key])\r\n          : mapper[key] ?? key;\r\n      result[newKey] = obj[key];\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Asserts that a condition is truthy. Throws an error with a message if the condition is falsy.\r\n   * Useful for runtime type checks and ensuring invariants.\r\n   *\r\n   * @param condition - Condition to assert truthy.\r\n   * @param message- Error message for the thrown exception.\r\n   * @throws {Error} Throws if the condition is falsy.\r\n   *\r\n   * @example\r\n   * assert(typeof value === \"string\", \"Value must be a string\");\r\n   */\r\n  export function assert(\r\n    condition: any,\r\n    message = \"Assertion failed\"\r\n  ): asserts condition {\r\n    if (!condition) {\r\n      throw new Error(message);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns a random element from an array, or null if the array is empty.\r\n   *\r\n   * @template T\r\n   * @param array - The array to sample from.\r\n   * @returns A randomly chosen element, or null if the array has no elements.\r\n   *\r\n   * @example\r\n   * sample([1, 2, 3]); // might return 2\r\n   * sample([]);        // returns null\r\n   */\r\n  export function sample<T>(array: T[]): T | null {\r\n    if (array.length === 0) return null;\r\n    const index = Math.floor(Math.random() * array.length);\r\n    return array[index];\r\n  }\r\n}\r\n"],"mappings":"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","names":["Datum","fs","target","index"]}